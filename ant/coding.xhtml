<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!-- H E A D ============================================================= -->
<head>
    <title>Coding</title>
</head>

<!-- B O D Y ============================================================= -->
<body>

<pre>
Guía de Codificación para Java
==============================


1. Introducción
---------------

La guía de codificación contiene un conjunto de reglas y recomendaciones que deben ser aplicacadas al código fuente
de cualquier proyecto de desarrollo de software. Cubren posibles problemas que no son detectados por el compilador
pero que pueden ser la causa de errores de mantenimiento, portabilidad, rendimiento, etc.

La razon principal de la adopción de este conjunto de reglas es estandarizar la estructura del código fuente, de
manera que pueda ser fácilmente entendida y modificada por cualquier otro desarrollador.

Las reglas descritas en este documento tienen la siguiente estructura:

* Id: identificación única de la regl.
* Obligatoriedad: importancia de la regla [siempre|recomendable|opcional].
* Descripcion: descripción de la regla.
* Motivo: motivo por el cual se aplica esta regla.
* Excepciones: casos particulares en los que se puede omitir el uso de esta regla. [opcional].
* Ejemplo: ejemplo ilustrativo de la regla.
  - Incorrecto: código mal escrito.
  - Correcto: código escrito correctamente.


2. Paquetes
-----------

* Id: package_names
* Obligatoriedad: siempre
* Descripcion: los nombres de los paquetes solo deben contener minúsculas y separar las palabras mediante '_'.
* Motivo: diferenciar claramente el nombre del paquete de el de el tipo.
* Ejemplo:
  - Correcto:
  - Incorrecto:

* Id: package_structure
* Obligatoriedad: recomendable
* Descripcion: el primero o los dos primeros paquetes de la jerarquia deben ser el nombre de la organización o su URL.
* Motivo: evitar posibles conflictos de nombres en los tipos.
* Ejemplo:
  - Correcto:
  - Incorrecto:

* Id: reserved_packages
* Obligatoriedad: opcional
* Descripcion: existen determinados nombres de paquetes reservados para propositos especificos como:
* Motivo: localizar facilmente algunas clases según su funcionalidad.
* Ejemplo:
  - Correcto:
  - Incorrecto:


3. Ficheros de Código Fuente
----------------------------

* Id: file_classes
* Obligatoriedad: recomendable
* Descripcion: codificar un tipo por cada fichero de codigo fuente (*.java)
* Motivo: facilitar la búsqueda del código fuente de una clase en el sistema de ficheros.
* Excepciones: clases anonimas.
* Ejemplo:
  - Correcto:
  - Incorrecto:

* Id: source_structure
* Obligatoriedad: siempre
* Descripcion: la estructura de un fichero de código fuente debe estar dividida en las
    siguientes secciones separadas por comentarios:
    - Cabecera (comentario con copyright e información del sistema de control de versiones.
    - Package
    - Imports
    - Tipos
* Motivo: útil para reconocer a primera vista las partes del fichero.
* Ejemplo:
  - Correcto:
  - Incorrecto:


3. Imports
----------

* Id: import_star
* Obligatoriedad: siempre
* Descripcion: evitar importar todas las clases de un paquete (usando '*')
* Motivo: reduce el tiempo de compilación y muestra claramente cuales son los tipos usados por esta clase y a que paquete pertenecen.
* Ejemplo:
  - Correcto:
  - Incorrecto:


4. Comentarios
--------------

* Id: javadoc
* Obligatoriedad: siempre
* Descripcion: utilizar comentarios javadoc CORRECTOS y COMPLETOS para todos los métodos, propiedades y tipos.
* Motivo: mantener facilmente la documentación técnica de los proyectos.
* Ejemplo:
  - Correcto:
  - Incorrecto:

4. Nomenclatura
---------------

* Id:
* Obligatoriedad: siempre
* Descripcion:
* Motivo:
* Ejemplo:
  - Correcto:
  - Incorrecto:
</pre>

<pre>
REGLAS DEL CODIGO FUENTE

-importancia: obligatorio | recomendable | opcional

Comentar todos los metodos y campos

Comprobar los argumentos de los metodos y funciones

Usar comentarios definidos para indicar partes pendientes, notas o errores conocidos

No usar llamadas a metodos anidadas (en la misma sentencia) ej. m1().m2().m3()

No controlar las excepciones mas generales (throwable, exception) en metodos que no sean puntos
de entrada (main, init, processRequest). Esto provoca que no puedan ser controladas por metodos
mas abajo en la pila de llamadas

Los metodos deben poder verse en una pantalla (unas 30 lineas como maximo)

Las clases no deben ser excesivamente largas (no mas de 500 lineas)

No debe haber mas de 5 niveles de indentacion (esto quiere decir que se puede dividir el metodo en
otros mas sencillos)

Acceder a metodos estaticos usando el nombre de la clase en vez de una instancia concreta

No se deben asignar valores a los parametros, para asegurarse, declarar los parametros como 'final'
en los metodos

Uso de los bucles for: evitar for (; i &lt; 10;) { i++ } en los casos en los que alguna de las partes
del bucle for es omitida, cambiar a otro tipo de bucle (while)

No usar asignaciones multiples o anidadas: i += j++; i = j = 10; i = (j = 25) + 30;

Usar asignaciones abreviadas: i = i + 10; -> i += 10;

Usar siempre el modificador de acceso más restrictivo (private a ser posible)

Documentar en los métodos el valor devuelto, casos especiales, valores validos para los parametros, etc.

Concatenar cadenas con 'MessageFormat'

Constantes deben ser static final
</pre>

<pre>
CODIGO FUENTE
=============
- El codigo fuente se debe guardar con el mismo formato (formatear el codigo con
  alguna herramienta -astyle, jalopy, tidy-). La uniformidad en el estilo del
  código facilita la tarea de comparar ficheros con herramientas de texto como
  diff.
- Los tabuladores se deben pasar a espacios (en los ficheros en los que esto no
  sea relevante, por ejemplo en los makefiles provocaría errores). Esto es útil
  debido a que las tabulaciones pueden ser de distintos tamaños según el editor
  y pueden estar mezcladas con espacios, lo que hace dificil editar el código
  con herramientas distintas asi como mantener un estilo de codificación homogeneo
  (ver el punto 1).
- Los espacios en blanco al final de cada linea deben ser eliminados. Siempre
  que no interfieran con la sintaxis del lenguaje.
- Las lineas restantes a partir del final del fichero deben ser eliminadas.
  Igual que las dos anteriores.
- La plantilla del documento debe ser homogenea para todos los ficheros de
  codigo fuente (usar plantillas con sustitución de patrones).
- Documentar el código fuente (usando alguna herramienta como javadoc -Java- o
  doxygen -C, C++, Java-
- Usar comentarios con un formato definido en el código para guardar las notas,
  errores y tareas pendientes (siempre que el sistema de documentación no lo
  soporte).
- Usar algún programa para auditar el código, es decir que compruebe que las reglas
  mencionadas anteriormente se cumplan y genere un informe en caso contrario.
- Uso y estilo de las trazas:
        * Permitir filtrar las trazas por componentes.
        * Poner solo la información relevante.
        * Que cada traza ocupe solo una línea, y en caso contrario indentar las lineas
          siguientes.
</pre>

<pre>
DOCUMENTACION
=============
- Definir plantillas para la documentación. Las más importantes son:
        * Manual de usuario.
        * Manual de instalación.
        * Ayuda en línea (HTML). Son recursos, no documentación.
        * Entorno (Desarrollo).
        * Diseño (Desarrollo).
        * Especificaciones (Desarrollo).
- Soporte para ficheros GNU (readme, changelog, todo, etc.) en formato XML.
  Estos datos deben estar dentro del código fuente y ser extraidos con alguna
  herramienta de reconocimiento de patrones de texto (grep podría valer).
- Documentación en XHTML u OpenOffice.

FICHEROS Y DIRECTORIOS
======================
Estas normas se seguiran, excepto en los casos en los que no sea posible debido
a exigencias del lenguaje o entorno. Por ejemplo en el nombrado de ficheros con
código fuente Java.
- En minusculas
- las palabras separadas por "_"

NOMBRADO DE VERSIONES
=====================
Patrones de nombrado de versiones.
X.Y.Z[-W] [comment] donde:
X - Version principal (grandes cambios)
Y - Version secundaria (mantenimiento, pequeñas funcionalidades)
Z - Versión ternaria (eliminación de errores, cambios triviales)
W - Madurez del codigo (opcional) (estable R, alfa A o beta B) (opcional)
comment - Comentario descriptivo de esa version en concreto (opcional)
Los caracteres no soportados por el sistema de control de versiones serán
sustituidos por '_'

Ejemplos:
0.0.1-A Pruebas --> En CVS --> 0_0_1_A_Pruebas
0.1.0-B Beta 5 --> En CVS --> 0_1_0_B_Beta_5
1.0.0-R Nueva release --> En CVS --> 1_0_0_R
1.0.1 --> En CVS --> 1_0_1
1.3.0-R --> En CVS --> 1_3_0_R

FORMATO DE LOS TIMESTAMP
========================
aaaammddHHmm
</pre>
PROYECTOS (ESTRUCTURA Y TAREAS COMUNES)
=======================================
- Compilar
- Reconstruir (rebuild)
- Limpiar (clean)
- Generar la documentación del código fuente.
- Sacar instantanea
- Crear estructura de directorios (estructura que funcione) para desarrollo (dist)
- Generar distribucion (zip, exe, rpm, deb, jar, war, dll, so, etc.) optimizada y firmada (produccion)
- Instalar

proyecto/                       directorio raiz del proyecto
bin/                        (temporal) directorio de los binarios
build/                      directorio con la información de construcción del proyecto
doc/                        directorio raiz de la documentación
srcdoc/                 (temporal) documentación del código fuente
design/                 documentación del diseño (arquitectura). UML diseño de tablas, etc. (XMI ó SVG)
development/            directorio con la información relacionada con el desarrollo
uiStyle.txt         estandares del diseño de interfaz de usuario (HTML, WML, Swing, ...)
codeStyle.txt       convenciones adoptadas para la codificación (nombrado de variables, comentarios (patrones para
comentarios con un significado especial -errores, tareas pendientes-) trazas, plantillas del código fuente)
enviroment.txt      definición del entorno (bases de datos, servidores, sistemas de control de versiones, maquinas relacionadas con el desarrollo)
related.txt         fuentes de información con información relevante de terceros (acerca de APIs, tutoriales, etc.)
installManual/          manual de instalación y configuración de la aplicación.
specs/                  especificación de requisitos de la aplicación
userManual/             manual de usuario
build.txt               información de compilación
changelog.txt           historial de cambios importantes entre versiones
license.txt             licencia
project.txt             descripción de los ficheros y directorios más importantes del proyecto
readme.txt              información importante acerca de la aplicación
todo.txt                lista de tareas pendientes
dist/                       (temporal) directorio con los ficheros empaquetados de la aplicación
etc/                        (opcional) ficheros y opciones de configuración
lib/                        (opcional) librerias externas usadas por el proyecto
misc/                       (opcional) Ficheros de utilidad del proyecto (los que no encajan en ningun otro sitio)
res/                        directorio de los recursos del proyecto (imagenes, ficheros de ayuda, ficheros de configuración...)
src/                        (opcional) código fuente del proyecto
ver/                        directorio donde se almacenan las instantaneas
build.bat                   script de compilación (windows)
build.sh                    script de compilación (unix)

DESARROLLO DE PROYECTOS (CICLO DE VIDA DEL SOFTWARE)
====================================================
- Toma de requerimientos (especificaciones).

- Definicicion del entorno:
+ Herramientas de desarrollo
* IDE
* Librerias
* Otras herramientas (documentadores, programas estilo make, etc.)
+ Control de versiones
+ Servidores
+ Bases de datos
+ Comunicación
+ Ofimatica

- Definición de la arquitectura

- División del trabajo

- Desarrollo

- Pruebas (ciclo de betas). 2 betas antes de una release. Las betas son versiones que
serán probadas a conciencia para encontrar fallos que deben ser resueltos antes de
sacar una release. (usar una base de datos de incidencias -ver herramientas en rep_common.txt-)

- Paso a producción. Mantenimiento de la aplicación. Gestion de parches.

<pre>

</pre>

<h1>Estilo SQL</h1>

<h1>Estilo Trazas</h1>

</body>

</html>
